{"challenge_id": "75e1ae11-b7bb-4a11-b1c1-4dd6245cf374", "task": "Write a function that defines a simple convolutional neural network (CNN) using PyTorch. The CNN should have 2 convolutional layers with ReLU activation functions, followed by max pooling layers. The final output should be a fully connected layer with 2 output units.", "code": "def simple_cnn():\n    import torch.nn as nn\n    class SimpleCNN(nn.Module):\n        def __init__(self):\n            super(SimpleCNN, self).__init__()\n            self.conv1 = nn.Conv2d(in_channels=1, out_channels=16, kernel_size=3, stride=1, padding=1)\n            self.relu1 = nn.ReLU()\n            self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n            self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n            self.relu2 = nn.ReLU()\n            self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n            self.fc = nn.Linear(32*7*7, 2)\n        def forward(self, x):\n            x = self.pool1(self.relu1(self.conv1(x)))\n            x = self.pool2(self.relu2(self.conv2(x)))\n            x = x.view(x.size(0), -1)\n            x = self.fc(x)\n            return x\n    return SimpleCNN()\n", "function_name": "simple_cnn", "test_case": []}
{"challenge_id": "d9dcdb52-431c-4837-bebd-d2d8f193f304", "task": "Write a function that takes in a string and prints 'Hello, World!' followed by the input string.", "code": "def hello_world(input_str):\n    print('Hello, World!', input_str)\n", "function_name": "hello_world", "test_case": ["Python"]}
{"challenge_id": "aef7ad84-6738-4fbf-8125-4bbd169b335a", "task": "Write a function to reverse a given list.", "code": "def reverse_list(lst):\n    return lst[::-1]\n", "function_name": "reverse_list", "test_case": [[1, 2, 3, 4, 5]]}
{"challenge_id": "0938ccc0-14b4-41ae-ac07-0754a7333c40", "task": "Implement a simple convolutional neural network (CNN) using PyTorch that takes in a 1-channel image (28x28) and outputs 10 classes. The CNN architecture should consist of 2 convolutional layers followed by 2 fully connected layers. Use ReLU activation functions for all layers.", "code": "def cnn_pytorch(input_channels):\n    import torch\n    import torch.nn as nn\n    import torch.nn.functional as F\n    class Net(nn.Module):\n        def __init__(self):\n            super(Net, self).__init__()\n            self.conv1 = nn.Conv2d(input_channels, 16, 3)\n            self.conv2 = nn.Conv2d(16, 32, 3)\n            self.fc1 = nn.Linear(32 * 5 * 5, 120)\n            self.fc2 = nn.Linear(120, 10)\n        def forward(self, x):\n            x = F.relu(self.conv1(x))\n            x = F.relu(self.conv2(x))\n            x = F.max_pool2d(x, 2)\n            x = x.view(-1, 32 * 5 * 5)\n            x = F.relu(self.fc1(x))\n            x = self.fc2(x)\n            return F.log_softmax(x, dim=1)\n    model = Net()\n    return model", "function_name": "cnn_pytorch", "test_case": [[1]]}
{"challenge_id": "f276ccee-ca30-428e-9647-d4e2460d9cb1", "task": "Write a function that converts a given string in Java naming convention to Python naming convention. In Java naming convention, variables start with a lowercase letter and each subsequent word starts with an uppercase letter. In Python naming convention, variables are in snake_case format where words are separated by underscores and all letters are lowercase.", "code": "def java_to_python(java_name):\n    python_name = ''\n    prev_upper = False\n    for char in java_name:\n        if char.isupper() and not prev_upper:\n            python_name += '_'\n            python_name += char.lower()\n        else:\n            python_name += char.lower()\n        prev_upper = char.isupper()\n    return python_name", "function_name": "java_to_python", "test_case": ["thisIsAVariableName"]}
{"challenge_id": "eb82dc84-22a1-43cc-bfcc-cbca81397062", "task": "Write a function that converts a given Haskell code snippet into JavaScript code snippet. The converter should consider basic data types, functions, and list manipulation functions such as map and filter.", "code": "def haskell_to_js(haskell_code: str) -> str:\n    # Convert Haskell code to equivalent JavaScript code\n    js_code = haskell_code.replace('::', '=')\n    js_code = js_code.replace('True', 'true')\n    js_code = js_code.replace('False', 'false')\n    js_code = js_code.replace('++', '+')\n    js_code = js_code.replace('filter', 'filter')\n    js_code = js_code.replace('map', 'map')\n    return js_code", "function_name": "haskell_to_js", "test_case": ["filter even [1,2,3,4]"]}
{"challenge_id": "09371e5a-f19a-4069-921a-1c3ac465da9f", "task": "Create a function that constructs a simple CNN (Convolutional Neural Network) model using PyTorch with 2 convolutional layers, 2 max pooling layers, and 2 fully connected layers. The CNN should take grayscale images as input with dimensions 28x28 and output 10 classes.", "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nclass SimpleCNN(nn.Module):\n    def __init__(self):\n        super(SimpleCNN, self).__init__()\n        self.conv1 = nn.Conv2d(1, 32, 3)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(32, 64, 3)\n        self.fc1 = nn.Linear(64 * 6 * 6, 128)\n        self.fc2 = nn.Linear(128, 10)\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 64 * 6 * 6)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x", "function_name": "SimpleCNN", "test_case": [[]]}
{"challenge_id": "9a1b3594-108f-4fd2-9966-e4d9d3e7676d", "task": "Given an integer n, write a function to return the nth Fibonacci number using recursion. Assume n is greater than or equal to 0.", "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)", "function_name": "fibonacci", "test_case": [6]}
{"challenge_id": "06c3241c-a824-4246-98f0-4427a2b550de", "task": "Write a recursive function to calculate the nth Fibonacci number. The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.", "code": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)", "function_name": "fibonacci", "test_case": [6]}
{"challenge_id": "eadcad9a-d845-4ae1-9d92-99160b186166", "task": "Given a list of distinct integers, find all possible permutations. Implement a function `find_permutations` that uses recursion to generate all permutations of the list.", "code": "def find_permutations(nums):\n    def backtrack(start=0):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    result = []\n    backtrack()\n    return result", "function_name": "find_permutations", "test_case": [[1, 2, 3]]}
