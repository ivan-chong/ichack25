{"challenge_id": "75e1ae11-b7bb-4a11-b1c1-4dd6245cf374", "task": "Write a function that defines a simple convolutional neural network (CNN) using PyTorch. The CNN should have 2 convolutional layers with ReLU activation functions, followed by max pooling layers. The final output should be a fully connected layer with 2 output units.", "code": "def simple_cnn():\n    import torch.nn as nn\n    class SimpleCNN(nn.Module):\n        def __init__(self):\n            super(SimpleCNN, self).__init__()\n            self.conv1 = nn.Conv2d(in_channels=1, out_channels=16, kernel_size=3, stride=1, padding=1)\n            self.relu1 = nn.ReLU()\n            self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n            self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, stride=1, padding=1)\n            self.relu2 = nn.ReLU()\n            self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n            self.fc = nn.Linear(32*7*7, 2)\n        def forward(self, x):\n            x = self.pool1(self.relu1(self.conv1(x)))\n            x = self.pool2(self.relu2(self.conv2(x)))\n            x = x.view(x.size(0), -1)\n            x = self.fc(x)\n            return x\n    return SimpleCNN()\n", "function_name": "simple_cnn", "test_case": []}
{"challenge_id": "d9dcdb52-431c-4837-bebd-d2d8f193f304", "task": "Write a function that takes in a string and prints 'Hello, World!' followed by the input string.", "code": "def hello_world(input_str):\n    print('Hello, World!', input_str)\n", "function_name": "hello_world", "test_case": ["Python"]}
{"challenge_id": "aef7ad84-6738-4fbf-8125-4bbd169b335a", "task": "Write a function to reverse a given list.", "code": "def reverse_list(lst):\n    return lst[::-1]\n", "function_name": "reverse_list", "test_case": [[1, 2, 3, 4, 5]]}
{"challenge_id": "0938ccc0-14b4-41ae-ac07-0754a7333c40", "task": "Implement a simple convolutional neural network (CNN) using PyTorch that takes in a 1-channel image (28x28) and outputs 10 classes. The CNN architecture should consist of 2 convolutional layers followed by 2 fully connected layers. Use ReLU activation functions for all layers.", "code": "def cnn_pytorch(input_channels):\n    import torch\n    import torch.nn as nn\n    import torch.nn.functional as F\n    class Net(nn.Module):\n        def __init__(self):\n            super(Net, self).__init__()\n            self.conv1 = nn.Conv2d(input_channels, 16, 3)\n            self.conv2 = nn.Conv2d(16, 32, 3)\n            self.fc1 = nn.Linear(32 * 5 * 5, 120)\n            self.fc2 = nn.Linear(120, 10)\n        def forward(self, x):\n            x = F.relu(self.conv1(x))\n            x = F.relu(self.conv2(x))\n            x = F.max_pool2d(x, 2)\n            x = x.view(-1, 32 * 5 * 5)\n            x = F.relu(self.fc1(x))\n            x = self.fc2(x)\n            return F.log_softmax(x, dim=1)\n    model = Net()\n    return model", "function_name": "cnn_pytorch", "test_case": [[1]]}
{"challenge_id": "f276ccee-ca30-428e-9647-d4e2460d9cb1", "task": "Write a function that converts a given string in Java naming convention to Python naming convention. In Java naming convention, variables start with a lowercase letter and each subsequent word starts with an uppercase letter. In Python naming convention, variables are in snake_case format where words are separated by underscores and all letters are lowercase.", "code": "def java_to_python(java_name):\n    python_name = ''\n    prev_upper = False\n    for char in java_name:\n        if char.isupper() and not prev_upper:\n            python_name += '_'\n            python_name += char.lower()\n        else:\n            python_name += char.lower()\n        prev_upper = char.isupper()\n    return python_name", "function_name": "java_to_python", "test_case": ["thisIsAVariableName"]}
{"challenge_id": "eb82dc84-22a1-43cc-bfcc-cbca81397062", "task": "Write a function that converts a given Haskell code snippet into JavaScript code snippet. The converter should consider basic data types, functions, and list manipulation functions such as map and filter.", "code": "def haskell_to_js(haskell_code: str) -> str:\n    # Convert Haskell code to equivalent JavaScript code\n    js_code = haskell_code.replace('::', '=')\n    js_code = js_code.replace('True', 'true')\n    js_code = js_code.replace('False', 'false')\n    js_code = js_code.replace('++', '+')\n    js_code = js_code.replace('filter', 'filter')\n    js_code = js_code.replace('map', 'map')\n    return js_code", "function_name": "haskell_to_js", "test_case": ["filter even [1,2,3,4]"]}
{"challenge_id": "09371e5a-f19a-4069-921a-1c3ac465da9f", "task": "Create a function that constructs a simple CNN (Convolutional Neural Network) model using PyTorch with 2 convolutional layers, 2 max pooling layers, and 2 fully connected layers. The CNN should take grayscale images as input with dimensions 28x28 and output 10 classes.", "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nclass SimpleCNN(nn.Module):\n    def __init__(self):\n        super(SimpleCNN, self).__init__()\n        self.conv1 = nn.Conv2d(1, 32, 3)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(32, 64, 3)\n        self.fc1 = nn.Linear(64 * 6 * 6, 128)\n        self.fc2 = nn.Linear(128, 10)\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 64 * 6 * 6)\n        x = F.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x", "function_name": "SimpleCNN", "test_case": [[]]}
{"challenge_id": "9a1b3594-108f-4fd2-9966-e4d9d3e7676d", "task": "Given an integer n, write a function to return the nth Fibonacci number using recursion. Assume n is greater than or equal to 0.", "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)", "function_name": "fibonacci", "test_case": [6]}
{"challenge_id": "06c3241c-a824-4246-98f0-4427a2b550de", "task": "Write a recursive function to calculate the nth Fibonacci number. The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.", "code": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)", "function_name": "fibonacci", "test_case": [6]}
{"challenge_id": "eadcad9a-d845-4ae1-9d92-99160b186166", "task": "Given a list of distinct integers, find all possible permutations. Implement a function `find_permutations` that uses recursion to generate all permutations of the list.", "code": "def find_permutations(nums):\n    def backtrack(start=0):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    result = []\n    backtrack()\n    return result", "function_name": "find_permutations", "test_case": [[1, 2, 3]]}
{"challenge_id": "e0d28c66-737e-4eb8-aaef-93ec011b32c3", "task": "Given a list of integers representing the heights of walls in a terraria game, return the maximum water units that can be trapped in between the walls.", "code": "def terraria_rain_trap(walls):\n    if not walls:\n        return 0\n    left_max = [0] * len(walls)\n    right_max = [0] * len(walls)\n    left_max[0] = walls[0]\n    right_max[-1] = walls[-1]\n    for i in range(1, len(walls)):\n        left_max[i] = max(left_max[i-1], walls[i])\n    for i in range(len(walls)-2, -1, -1):\n        right_max[i] = max(right_max[i+1], walls[i])\n    trapped_water = 0\n    for i in range(len(walls)):\n        trapped_water += max(0, min(left_max[i], right_max[i]) - walls[i])\n    return trapped_water", "function_name": "terraria_rain_trap", "test_case": [[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]]}
{"challenge_id": "a0238a7c-6042-4197-8d87-b624a43b07a3", "task": "Write a function that prints 'Hello, World!' when called.", "code": "def print_hello_world():\n    print('Hello, World!')", "function_name": "print_hello_world", "test_case": []}
{"challenge_id": "33d046a4-8513-413d-bf12-d14cd10dd14f", "task": "Create a function that takes a list of blocks as input and returns the total number of diamond blocks in the list.", "code": "def count_diamond_blocks(blocks):\n    return blocks.count('diamond')", "function_name": "count_diamond_blocks", "test_case": [["stone", "diamond", "diamond", "wood", "diamond"]], "explanation": "Minecraft is a popular sandbox video game where players can build and explore virtual worlds made up of blocks. In Minecraft, players can craft tools, mine for resources, and build structures to survive and thrive in their world."}
{"challenge_id": "ca2a4f4a-666d-47ee-9b6c-c9279d3d5712", "task": "Write a function that generates a sentence using a large language model.", "code": "def generate_sentence():\n    from transformers import pipeline\n    generator = pipeline('text-generation', model='distilgpt2')\n    result = generator('In a world where humans and robots coexist', max_length=50, num_return_sequences=1, do_sample=True)\n    return result[0]['generated_text']", "function_name": "generate_sentence", "test_case": [], "explanation": "Large language models are neural network models designed to process and generate human language. They are trained on massive datasets to learn the patterns and structures of language, allowing them to perform tasks like text generation, translation, and sentiment analysis. These models have revolutionized natural language processing and have achieved state-of-the-art performance in various language-related tasks."}
{"challenge_id": "bcae4c10-f6a9-4592-b123-c3c53fec5d25", "task": "Create a function that adds two constant tensors and returns the result.", "code": "def add_constant_tensors():\n    import tensorflow as tf\n    tensor1 = tf.constant(3)\n    tensor2 = tf.constant(5)\n    result = tf.add(tensor1, tensor2)\n    with tf.Session() as sess:\n        output = sess.run(result)\n    return output", "function_name": "add_constant_tensors", "test_case": [], "explanation": "TensorFlow is an open-source machine learning framework created by Google. It is widely used for building and training deep learning models. TensorFlow represents computations as graphs where nodes are operations and edges are tensors (multi-dimensional arrays). The graph is executed within a TensorFlow session."}
{"challenge_id": "629a275f-fccf-4180-b039-3d04df3e9c47", "task": "Write a function that calculates the mean of a list of numbers.", "code": "def calculate_mean(nums):\n    return sum(nums) / len(nums)", "function_name": "calculate_mean", "test_case": [[1, 2, 3, 4, 5]], "explanation": "Statistical analysis involves collecting, organizing, analyzing, interpreting, and presenting data. It helps in making informed decisions by summarizing and drawing conclusions from the data. Common statistical techniques include mean, median, mode, standard deviation, hypothesis testing, and regression analysis."}
{"challenge_id": "8a21790c-d08d-487f-882a-5cb1065ed7e0", "task": "Given a binary tree, implement a function to perform BFS traversal and return a list of node values visited in BFS order.", "code": "def bfs_binary_tree(root):\n    result = []\n    if root is None:\n        return result\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        result.append(node.val)\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    return result", "function_name": "bfs_binary_tree", "test_case": [[1, 2, 3, 4, 5]], "explanation": "Breadth First Search (BFS) is a graph traversal algorithm that starts traversing the graph from a selected node and visits all of its neighbors before moving on to the next level of neighbors. It uses a queue data structure to keep track of nodes to be visited next."}
{"challenge_id": "7b60366c-21b4-4cb2-8755-973baa6beaf1", "task": "Given a graph represented as an adjacency list and a start node, implement a depth-first search (DFS) algorithm to return all nodes visited in the order they were visited.", "code": "def dfs(graph, start_node):\n    visited = []\n    stack = [start_node]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.append(node)\n            stack.extend([neighbor for neighbor in graph[node] if neighbor not in visited])\n    return visited", "function_name": "dfs", "test_case": [[[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]], 0], "explanation": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root node and explores as far as possible along each branch before backtracking."}
{"challenge_id": "f5830a41-90ae-4996-91a7-e9e62a7ce8a0", "task": "Given a graph represented as an adjacency list and a starting node, implement a depth first search (DFS) algorithm to traverse the graph and return the order of visited nodes.", "code": "def dfs(graph, start):\n    visited = set()\n    result = []\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            stack.extend([neighbor for neighbor in graph.get(node, []) if neighbor not in visited])\n    return result", "function_name": "dfs", "test_case": [[[1, 2, 3], 1]], "explanation": "Depth First Search (DFS) is an algorithm used for traversing or searching tree or graph data structures. It starts at the root node and explores as far as possible along each branch before backtracking. This is often implemented using a stack or recursion. In the context of graphs, DFS can help find connected components, detect cycles, and determine reachable nodes."}
{"challenge_id": "a42f2bfa-24db-4ef6-ac64-bc5a2adff18a", "task": "Given a binary tree, implement a function to perform BFS traversal and return a list of the nodes visited in the order they were visited.", "code": "def bfs_traversal(root):\n    if not root:\n        return []\n    queue = [root]\n    result = []\n    while queue:\n        node = queue.pop(0)\n        result.append(node.val)\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    return result", "function_name": "bfs_traversal", "test_case": [[3, 9, 20, null, null, 15, 7]], "explanation": "Breadth-first search (BFS) is an algorithm used for traversing or searching tree or graph data structures. It starts at the root node and explores all neighboring nodes at the present depth prior to moving on to nodes at the next depth level. It allows you to find the shortest path in an unweighted graph."}
{"challenge_id": "d4fbcb0f-4425-470e-8374-f9cce40d903f", "task": "Write a function that takes in two integers and returns the sum of the two numbers.", "code": "def add_numbers(num1, num2):\n    return num1 + num2", "function_name": "add_numbers", "test_case": [5, 3], "explanation": "Adding numbers is a fundamental operation in mathematics and programming. In Python, addition is performed using the '+' operator. When adding numbers, the values are simply summed together to get a total value."}
{"challenge_id": "7d417460-c0b9-42b4-91a8-5fe06e2b8b56", "task": "Write a function that takes a list of integers and returns the sum of all the integers in the list.", "code": "def sum_integers(lst):\n    total = 0\n    for num in lst:\n        total += num\n    return total", "function_name": "sum_integers", "test_case": [[1, 2, 3, 4, 5]], "explanation": "A for loop is used for iterating over a sequence (list, tuple, dictionary, set, or string) or other iterable objects. It executes a block of code multiple times, with the loop variable taking on the value of each element in the sequence in turn."}
{"challenge_id": "ed73774b-bcd6-480f-b92c-49071fc0384e", "task": "Implement a function to perform Min-Max Scaling. The function should take a list of numerical features and return the scaled version, with each feature value rescaled to fall within the range [0,1].", "code": "def min_max_scale(features):\n    min_val = min(features)\n    max_val = max(features)\n    if min_val == max_val:  # All elements are equal\n        return [0.0] * len(features)\n    return [(x - min_val) / (max_val - min_val) for x in features]", "function_name": "min_max_scale", "test_case": [[1, 2, 3, 4, 5]], "explanation": "In Machine Learning, feature scaling is an essential preprocessing technique used to standardize the range of independent variables or features of data. This process helps in improving the performance and training stability of models. Common techniques include Min-Max Scaling and Standardization (Z-score Normalization). Understanding how to implement feature scaling from scratch can deepen your comprehension of data preprocessing in ML workflows."}
{"challenge_id": "ccf760d1-8d01-4882-9a2f-73d1c4fd8e2e", "task": "Write a function called merge_sort that implements the merge sort algorithm using recursion. The function should take a list of integers and return a new sorted list. Merge sort is a divide and conquer algorithm that continually splits a list into halves, recursively sorts the halves, and then merges the sorted halves.", "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    def merge(left, right):\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)", "function_name": "merge_sort", "test_case": [[3, 1, 4, 1, 5, 9, 2, 6, 5, 3]], "explanation": "Recursion is a programming strategy where a function calls itself to solve smaller instances of the same problem. The basic idea behind recursion is to break down complex problems into simpler ones. Each recursive function has a base case, which stops the recursion, and a recursive case, which breaks the problem down into sub-problems. A challenging recursive problem often involves tracking multiple recursive branches, understanding the recursive tree, and managing the call stack effectively."}
{"challenge_id": "2ef344a6-ee3d-448c-aaec-953d6baa160b", "task": "Write a function `validate_docker_container_names` that receives a list of potential Docker container names and returns only the valid ones. A valid Docker container name must only contain lowercase letters, numbers, dashes ('-'), and underscores ('_'). The name must also not start or end with a dash or underscore and should be between 1 and 30 characters long.", "code": "def validate_docker_container_names(names):\n    def is_valid(name):\n        if len(name) < 1 or len(name) > 30:\n            return False\n        if not (name[0].isalnum() and name[-1].isalnum()):\n            return False\n        for char in name:\n            if not (char.islower() or char.isdigit() or char in ['-', '_']):\n                return False\n        return True\n    return [name for name in names if is_valid(name)]", "function_name": "validate_docker_container_names", "test_case": [["my-container", "invalid_container_", "-wrongStart", "GOODname"]], "explanation": "Docker is a platform that allows developers to package applications into containers. These containers can run on any system that has Docker installed, providing a consistent environment regardless of where the container is deployed. In this exercise, we're going to simulate a basic routine that checks if a list of Docker container names are valid based on a set of rules."}
